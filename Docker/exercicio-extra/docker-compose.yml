version: '3.8'

services:
  # 1. Serviço da API (Backend)
  api:
    build:
      context: ./api
      # Usa o estágio de produção do Dockerfile otimizado
      target: production
    ports:
      - "3000:3000"
    # BOAS PRÁTICAS: Carrega variáveis de ambiente do arquivo .env
    env_file:
      - .env
    environment:
      # Variáveis para a API se conectar ao DB. Usamos ${} para ler do .env
      DB_HOST: db # O hostname é o nome do serviço do DB no Compose
      DB_USER: ${POSTGRES_USER}
      DB_PASSWORD: ${POSTGRES_PASSWORD}
      DB_NAME: ${POSTGRES_DB}
    # GERENCIAMENTO DE DEPENDÊNCIA AVANÇADO:
    # A API só inicia quando o DB estiver "saudável" (healthcheck passar)
    depends_on:
      db:
        condition: service_healthy

  # 2. Serviço do Banco de Dados (PostgreSQL)
  db:
    image: postgres:16-alpine # Imagem oficial leve
    # Carrega variáveis de ambiente do arquivo .env
    env_file:
      - .env
    # PERSISTÊNCIA: Configura um volume nomeado para persistência dos dados
    volumes:
      - db_data:/var/lib/postgresql/data
    # HEALTHCHECK (Requisito 2): Define como o Docker deve verificar se o DB está pronto
    healthcheck:
      test: ["CMD", "pg_isready", "-U", "${POSTGRES_USER}"] # Comando para checar a disponibilidade
      interval: 10s # Intervalo entre as checagens
      timeout: 5s   # Tempo limite para o comando
      retries: 5    # Número de tentativas antes de falhar

  # 3. Serviço da Interface de Administração (Adminer)
  adminer:
    image: adminer:latest # Imagem oficial
    ports:
      - "8080:8080" # Expõe a porta para acesso externo
    environment:
      # Configura o Adminer para se conectar ao nosso serviço de DB
      ADMINER_DEFAULT_SERVER: db # Usa o hostname do serviço 'db'
    # Dependência simples: Adminer só inicia depois que o DB iniciar
    depends_on:
      - db

# Define o volume nomeado
volumes:
  db_data: